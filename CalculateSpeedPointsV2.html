<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GPS Route Generator (by road)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #f2f2f2;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h2 { margin-top: 20px; color: #2c3e50; }

    #controls {
      margin: 10px 0;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    input, button {
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 14px;
    }

    #map {
      height: 70vh;
      width: 95%;
      max-width: 1400px;
      margin: 20px 0;
      border: 2px solid #3498db;
      border-radius: 8px;
    }

    .saveBtn {
      padding: 12px 24px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      margin-bottom: 15px;
      transition: background-color 0.3s ease;
    }

    .saveBtn:hover { background-color: #2980b9; }
  </style>
</head>
<body>

  <h2>GPS Route Generator (by road)</h2>

  <div id="controls">
    <label>Start (lat,lon):</label>
    <input id="start" placeholder="40.4168,-3.7038" readonly>

    <label>Destination (lat,lon):</label>
    <input id="end" placeholder="40.4379,-3.6793" readonly>

    <label>Speed (km/h):</label>
    <input type="number" id="speed" value="30" min="1">

    <button id="routeBtn">Draw Route</button>
  </div>

  <div id="map"></div>

  <button class="saveBtn" id="saveBtn">Save simulated route to CSV</button>
  <button class="saveBtn" id="saveReversedBtn">Save reversed route to CSV</button>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>

    // === MAP INITIALIZATION ===
    const map = L.map('map').setView([40.4168, -3.7038], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    let routeLayer = null;
    let currentRoute = [];


    // === RIGHT CLICK: COPY COORDINATES ===
    map.on('contextmenu', function(event) {
      const lat = event.latlng.lat.toFixed(6);
      const lon = event.latlng.lng.toFixed(6);

      // If the start field is empty, place the coordinates there
      if (!document.getElementById("start").value) {
        document.getElementById("start").value = `${lat},${lon}`;
      } else if (!document.getElementById("end").value) {
        // If the end field is empty, place the coordinates there
        document.getElementById("end").value = `${lat},${lon}`;
      }

      // Show popup with coordinates
      L.popup()
        .setLatLng(event.latlng)
        .setContent(`üìç <b>${lat}, ${lon}</b>`)
        .openOn(map);
    });


    // === HAVERSINE DISTANCE ===
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
                Math.cos(lat1 * Math.PI / 180) *
                Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) ** 2;
      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }


    // === GENERATE GPS POINTS ===
    function generateGPSPoints(route, speedKmh) {
      const speedMs = speedKmh * 1000 / 3600;
      let gps = [];
      let time = 0;
      const dt = 0.1;

      for (let i = 0; i < route.length - 1; i++) {
        const [lat1, lon1] = route[i];
        const [lat2, lon2] = route[i + 1];

        const distM = haversineDistance(lat1, lon1, lat2, lon2) * 1000;
        const totalT = distM / speedMs;
        const steps = Math.max(1, Math.floor(totalT / dt));

        for (let j = 0; j <= steps; j++) {
          const f = j / steps;
          const lat = lat1 + (lat2 - lat1) * f;
          const lon = lon1 + (lon2 - lon1) * f;

          gps.push([time.toFixed(1), lat, lon, 99.999]);
          time += dt;
        }
      }
      return gps;
    }


    // === GET ROUTE FROM OSRM ===
    async function getRouteFromOSRM(latA, lonA, latB, lonB) {
      const url =
        `https://router.project-osrm.org/route/v1/driving/${lonA},${latA};${lonB},${latB}?overview=full&geometries=geojson`;

      try {
        const res = await fetch(url);
        const data = await res.json();

        if (!data.routes || !data.routes.length) {
          throw new Error("No route found");
        }

        // Check that the geometry is properly defined
        console.log("OSRM Response:", data);

        // The route geometry should be in the correct format (array of coordinates)
        const route = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);
        return route;

      } catch (error) {
        alert("Error getting the route from the server: " + error.message);
        return [];
      }
    }


    // === DRAW ROUTE BUTTON ===
    document.getElementById("routeBtn").addEventListener("click", async () => {
      try {
        const [latA, lonA] = document.getElementById("start").value.split(",").map(Number);
        const [latB, lonB] = document.getElementById("end").value.split(",").map(Number);

        const route = await getRouteFromOSRM(latA, lonA, latB, lonB);

        if (route.length === 0) return;

        if (routeLayer) map.removeLayer(routeLayer);

        routeLayer = L.polyline(route, { color: "blue" }).addTo(map);
        map.fitBounds(routeLayer.getBounds());
        currentRoute = route;

        alert(`Route drawn with ${route.length} road points.`);
      } catch (e) {
        alert("Error: " + e.message);
      }
    });


    // === SAVE CSV FUNCTION ===
    function saveCSV(route, speed, reversed = false) {
      const sim = generateGPSPoints(route, speed);

      const csv = sim.map(p =>
        `${p[0]}, ${p[1].toFixed(9)}, ${p[2].toFixed(9)}, ${p[3]}`
      ).join("\n");

      const blob = new Blob([csv], { type: "text/csv" });
      const link = document.createElement("a");

      const suffix = reversed ? "_reversed" : "";
      link.download = `route_${speed}kmh${suffix}.csv`;
      link.href = URL.createObjectURL(blob);
      link.click();
    }


    // === SAVE NORMAL ROUTE BUTTON ===
    document.getElementById("saveBtn").addEventListener("click", () => {
      if (currentRoute.length === 0)
        return alert("First draw a route.");

      const speed = Number(document.getElementById("speed").value);
      saveCSV(currentRoute, speed, false);
    });


    // === SAVE REVERSED ROUTE BUTTON ===
    document.getElementById("saveReversedBtn").addEventListener("click", () => {
      if (currentRoute.length === 0)
        return alert("First draw a route.");

      const speed = Number(document.getElementById("speed").value);

      const reversedRoute = [...currentRoute].reverse();

      saveCSV(reversedRoute, speed, true);
    });

  </script>

</body>
</html>

